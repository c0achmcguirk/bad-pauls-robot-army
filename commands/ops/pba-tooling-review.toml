description = "Analyze developer tooling and workflow to create an improvement plan"
prompt = """
First, activate the 'pba-workspace-tools' skill to ensure you have the correct tool mappings for this environment.

Using the pba-toolsmith skill, prepare a tooling review report. You must analyze the developer experience, tooling, and workflows to create a comprehensive improvement plan WITHOUT making any changes.

## Tool Configuration

**IMPORTANT**: Consult the pba-workspace-tools skill for your organization's configured tools.
Use ONLY the tools listed in the Active Configuration section of pba-workspace-tools.
If a capability is not configured, inform the user and continue with available capabilities.

## Input Parsing
The user invoked: /tooling-review {{args}}

Valid scopes:
- **No argument**: Analyze the entire project
- **File/directory path**: Scope analysis to that specific path
- **"current changes"**: Analyze uncommitted changes (use source_control `status` and `diff_uncommitted` capabilities)
- **"recent changes"**: Analyze recent commits (use source_control `log` capability)
- **Change request reference**: Analyze a specific PR/CL (use change_requests `view` and `diff` capabilities)

### Scope Resolution
Consult pba-workspace-tools for source_control and change_requests capabilities:

1. If scope is "current changes":
   - Use the `status` capability to identify changed files
   - Use the `diff_uncommitted` capability to see uncommitted changes
   - Focus analysis on modified code only

2. If scope is "recent changes":
   - Use the `log` capability to see recent commits
   - Analyze changes from recent development

3. If scope matches the change_requests `reference_format`:
   - Extract the change request ID from the scope
   - Use change_requests `view` capability to get details
   - Use change_requests `diff` capability to get the changes
   - Focus on files changed in the change request

4. If scope is a path:
   - Verify the path exists
   - Scope analysis to that path

5. If no scope provided:
   - Analyze the entire project

## Your Task
1. First, assess current developer tooling and workflows
2. Identify pain points and inefficiencies
3. Find opportunities for automation and improvement
4. Create a prioritized tooling improvement plan
5. Save your plan as a markdown file in the /reports directory

## Analysis Steps
1. **Current Tooling Assessment**
   - Development environment setup
   - Build and test tools
   - IDE configurations
   - Version control workflows
   - CI/CD pipeline
   - Developer scripts and utilities

2. **Workflow Analysis**
   - Time from clone to first run
   - Common developer tasks
   - Repetitive manual processes
   - Debugging workflows
   - Deployment processes
   - Documentation accessibility

3. **Pain Points Identification**
   - Setup complexity
   - Build/test speed
   - Debugging difficulties
   - Missing automation
   - Tool fragmentation
   - Knowledge gaps

## Output Format
Create a markdown file at `/reports/tooling-review-{timestamp}.md` with:

```markdown
# Tooling Review Plan
Generated: {timestamp}
Scope: {full_path_or_entire_project}

## Executive Summary
Brief overview of tooling state and improvement opportunities

## Current Developer Experience
### Setup Process
- Steps required: X
- Time to first run: Y minutes
- Common issues: List
- Documentation quality: Rating

### Daily Workflows
- Build time: X seconds
- Test execution: Y minutes
- Hot reload: Available/Missing
- Debugging tools: List

## Tooling Inventory
### Build Tools
- Build system: {tool} v{version}
- Package manager: {tool}
- Task runner: {tool}
- Bundler: {tool}

### Development Tools
- IDE support: List
- Linting: {tools}
- Formatting: {tools}
- Type checking: {tools}

### Testing & Quality
- Test runner: {tool}
- Coverage: {tool}
- Static analysis: {tools}
- Performance profiling: {tools}

## Pain Points & Inefficiencies
### Critical Issues
- [ ] Setup takes > 30 minutes
- [ ] No hot reload capability
- [ ] Manual deployment process

### Major Friction Points
- [ ] Slow test execution
- [ ] Complex debugging setup
- [ ] Inconsistent code formatting

### Minor Improvements
- [ ] Missing helpful scripts
- [ ] Outdated documentation
- [ ] No IDE templates

## Improvement Plan
### Quick Wins (1-3 days)
1. Add setup automation script
2. Create helpful aliases/shortcuts
3. Configure IDE settings
4. Add pre-commit hooks

### Major Improvements (1-2 weeks)
1. Implement hot reload
2. Optimize build pipeline
3. Add debugging helpers
4. Create CLI tools

### Transformative Changes (2-4 weeks)
1. Containerize development
2. Implement full CI/CD
3. Add performance monitoring
4. Create developer portal

## Automation Opportunities
### Immediate Automation
- [ ] Dependency installation
- [ ] Environment setup
- [ ] Code formatting
- [ ] Common tasks

### Build Process
- [ ] Incremental builds
- [ ] Parallel execution
- [ ] Cache optimization
- [ ] Asset optimization

### Testing
- [ ] Test selection
- [ ] Parallel test runs
- [ ] Automatic retries
- [ ] Coverage reporting

## Proposed Tools & Scripts
### New Tools
| Tool | Purpose | Benefit |
|------|---------|---------|
| Tool X | Build optimization | 50% faster builds |
| Tool Y | Code generation | Reduce boilerplate |

### Custom Scripts
- `dev-setup`: One-command setup
- `dev-test`: Smart test runner
- `dev-debug`: Debug helper
- `dev-deploy`: Deployment tool

## IDE Enhancements
### VS Code (or relevant IDE)
- Recommended extensions
- Workspace settings
- Debug configurations
- Task definitions

### Editor Agnostic
- EditorConfig setup
- Language server config
- Snippets/templates
- Keybinding suggestions

## Documentation Improvements
- [ ] Interactive setup guide
- [ ] Troubleshooting guide
- [ ] Video walkthroughs
- [ ] Architecture diagrams

## Success Metrics
### Before
- Setup time: X minutes
- Build time: Y seconds
- Test time: Z minutes
- TTFB (Time to first bug fix): A hours

### After (Projected)
- Setup time: < 5 minutes
- Build time: 50% reduction
- Test time: 70% reduction
- TTFB: 50% reduction

## Implementation Roadmap
### Week 1
- Implement quick wins
- Create setup automation
- Add essential scripts

### Week 2-3
- Optimize build pipeline
- Implement hot reload
- Add debugging tools

### Week 4
- Documentation overhaul
- Training materials
- Feedback collection

## Recommendations
- Adopt monorepo tooling
- Implement design system
- Add error tracking
- Create metrics dashboard

## Estimated Impact
- Developer productivity: +40%
- Onboarding time: -80%
- Build/test time: -60%
- Developer satisfaction: High
```

Remember: DO NOT make any changes. Only analyze and report.
---

## CRITICAL: Report Generation

**YOU MUST CREATE THE REPORT FILE.** This is not optional.

### Final Steps (MANDATORY)

1. **Create the report file** using the Write tool at the specified path:
   - Path format: `/reports/{command-name}-{scope}-{timestamp}.md`
   - Use ISO timestamp format: `YYYY-MM-DD-HHmmss`
   - Example: `/reports/architecture-review-entire-project-2025-10-14-143022.md`

2. **Fill in ALL sections** of the report template
   - Do not leave placeholder text
   - Provide specific, actionable findings
   - Include file paths and line numbers where relevant

3. **Confirm completion** by telling the user:
   - "Report saved to: [full path]"
   - Brief summary of key findings
   - Next steps or how to use the report

### Common Mistakes to Avoid

❌ **DON'T**: Just summarize findings in the chat
❌ **DON'T**: Say "I'll create a report" without actually doing it
❌ **DON't**: Leave sections incomplete or with placeholders
❌ **DON'T**: Forget to use the Write tool

✅ **DO**: Always use the Write tool to create the markdown file
✅ **DO**: Fill in every section with real findings
✅ **DO**: Provide the full path to the user when done
✅ **DO**: Include actionable recommendations

### Verification Checklist

Before responding to the user, verify:
- [ ] Report file created with Write tool
- [ ] All template sections filled in
- [ ] Specific findings with file references
- [ ] Actionable recommendations included
- [ ] Timestamp in filename
- [ ] Full path provided to user

**Remember**: The report is the primary deliverable. The chat summary is secondary.
"""
